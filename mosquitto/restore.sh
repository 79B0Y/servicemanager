#!/data/data/com.termux/files/usr/bin/bash
# =============================================================================
# Mosquitto 还原脚本
# 版本: v1.1.0
# 功能: 还原备份文件或生成默认配置文件，支持 tar.gz 和 zip 格式
# 更新: 修复函数引用、增强错误处理、优化配置同步逻辑
# =============================================================================

set -euo pipefail

# 加载统一路径定义
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/common_paths.sh" || {
    echo "Error: Cannot load common paths"
    exit 1
}

# 设置脚本特定的日志文件
LOG_FILE="$LOG_FILE_RESTORE"

# 确保必要目录存在
ensure_directories

START_TIME=$(date +%s)
CUSTOM_BACKUP_FILE="${RESTORE_FILE:-}"

# -----------------------------------------------------------------------------
# 生成默认配置文件
# -----------------------------------------------------------------------------
generate_default_config() {
    log "generating default configuration"
    
    # 确保配置目录存在
    mkdir -p "$MOSQUITTO_CONF_DIR"
    mkdir -p "$MOSQUITTO_LOG_DIR"
    
    # 获取 MQTT 配置
    if ! load_mqtt_conf; then
        log_warn "failed to load MQTT config, using defaults"
        MQTT_USER="admin"
        MQTT_PASS="admin"
    fi
    
    # 生成默认配置文件
    cat > "$MOSQUITTO_CONF_FILE" << EOF
# Mosquitto Configuration File
# Auto-generated by servicemanager restore script
# Generated on: $(date)

# Network Settings
port 1883
bind_address 0.0.0.0

# WebSocket Support
listener 9001
protocol websockets

# Authentication
allow_anonymous false
password_file $MOSQUITTO_PASSWD_FILE

# Persistence
persistence true
persistence_location $TERMUX_VAR_DIR/lib/mosquitto/

# Logging
log_dest file $MOSQUITTO_LOG_DIR/mosquitto.log
log_type error
log_type warning
log_type notice
log_type information
log_timestamp true

# Security
max_connections 100
max_inflight_messages 20
max_queued_messages 100

# Client settings
clientid_prefixes
persistent_client_expiration 1m
EOF
    
    # 创建管理员用户
    if echo "$MQTT_USER:$MQTT_PASS" | mosquitto_passwd -c "$MOSQUITTO_PASSWD_FILE" "$MQTT_USER"; then
        chmod 600 "$MOSQUITTO_PASSWD_FILE"
        log "default user created: $MQTT_USER"
    else
        log_error "failed to create default user"
        return 1
    fi
    
    log "default configuration generated successfully"
    return 0
}

# -----------------------------------------------------------------------------
# 检测和处理ZIP文件
# -----------------------------------------------------------------------------
process_zip_file() {
    local zip_file="$1"
    local output_dir="$2"
    
    log "processing ZIP file: $(basename "$zip_file")"
    
    # 创建临时解压目录
    local temp_extract_dir="$TEMP_DIR/zip_extract_$$"
    mkdir -p "$temp_extract_dir"
    
    # 解压ZIP文件
    if ! unzip -q "$zip_file" -d "$temp_extract_dir"; then
        log_error "failed to extract ZIP file: $(basename "$zip_file")"
        rm -rf "$temp_extract_dir"
        return 1
    fi
    
    # 查找有效的mosquitto数据结构
    local data_dir_in_zip=""
    
    # 检查直接包含配置文件的情况
    if [ -f "$temp_extract_dir/mosquitto.conf" ]; then
        data_dir_in_zip="."
        log_debug "found mosquitto.conf in ZIP root"
    else
        # 查找backup_*目录
        local backup_dirs=$(find "$temp_extract_dir" -name "backup_*" -type d | head -1)
        if [ -n "$backup_dirs" ]; then
            data_dir_in_zip=$(basename "$backup_dirs")
            log_debug "found backup directory: $data_dir_in_zip"
        else
            # 查找包含mosquitto.conf的任何目录
            local conf_path=$(find "$temp_extract_dir" -name "mosquitto.conf" -type f | head -1)
            if [ -n "$conf_path" ]; then
                data_dir_in_zip=$(dirname "$conf_path" | sed "s|$temp_extract_dir/||")
                log_debug "found mosquitto.conf in: $data_dir_in_zip"
            fi
        fi
    fi
    
    if [ -z "$data_dir_in_zip" ]; then
        log_error "no valid mosquitto data found in ZIP file"
        rm -rf "$temp_extract_dir"
        return 1
    fi
    
    # 创建标准tar.gz格式
    local converted_file="$BACKUP_DIR/mosquitto_converted_$(date +%Y%m%d_%H%M%S).tar.gz"
    
    if [ "$data_dir_in_zip" = "." ]; then
        # 直接打包整个临时目录
        if tar -czf "$converted_file" -C "$temp_extract_dir" .; then
            log "ZIP converted to tar.gz: $(basename "$converted_file")"
        else
            log_error "failed to create tar.gz from ZIP"
            rm -rf "$temp_extract_dir"
            return 1
        fi
    else
        # 打包指定的数据目录
        if tar -czf "$converted_file" -C "$temp_extract_dir" "$data_dir_in_zip"; then
            log "ZIP converted to tar.gz: $(basename "$converted_file")"
        else
            log_error "failed to create tar.gz from ZIP"
            rm -rf "$temp_extract_dir"
            return 1
        fi
    fi
    
    # 清理临时目录
    rm -rf "$temp_extract_dir"
    
    # 返回转换后的文件路径
    echo "$converted_file"
    return 0
}

# -----------------------------------------------------------------------------
# 验证备份文件完整性
# -----------------------------------------------------------------------------
validate_backup_file() {
    local backup_file="$1"
    
    log "validating backup file: $(basename "$backup_file")"
    
    # 检查文件是否存在且可读
    if [ ! -f "$backup_file" ] || [ ! -r "$backup_file" ]; then
        log_error "backup file not found or not readable: $backup_file"
        return 1
    fi
    
    # 检查文件大小
    local file_size=$(du -k "$backup_file" | cut -f1)
    if [ "$file_size" -lt 1 ]; then
        log_error "backup file is empty: $backup_file"
        return 1
    fi
    
    # 检查tar.gz文件完整性
    if ! tar -tzf "$backup_file" >/dev/null 2>&1; then
        log_error "backup file is corrupted or invalid: $backup_file"
        return 1
    fi
    
    # 检查是否包含关键文件
    local has_mosquitto_conf=false
    if tar -tzf "$backup_file" | grep -q "mosquitto.conf$"; then
        has_mosquitto_conf=true
    fi
    
    if [ "$has_mosquitto_conf" = false ]; then
        log_warn "backup file does not contain mosquitto.conf"
        # 不是致命错误，可能是部分备份
    fi
    
    log "backup file validation passed"
    return 0
}

# -----------------------------------------------------------------------------
# 还原配置文件
# -----------------------------------------------------------------------------
restore_configuration_files() {
    local extracted_dir="$1"
    local restored_files=()
    
    log "restoring configuration files from: $extracted_dir"
    
    # 查找提取的数据目录
    local data_dir="$extracted_dir"
    if [ ! -f "$data_dir/mosquitto.conf" ]; then
        # 查找包含配置文件的子目录
        local subdirs=$(find "$extracted_dir" -name "mosquitto.conf" -type f | head -1)
        if [ -n "$subdirs" ]; then
            data_dir=$(dirname "$subdirs")
            log_debug "found data in subdirectory: $data_dir"
        fi
    fi
    
    # 恢复主配置文件
    if [ -f "$data_dir/mosquitto.conf" ]; then
        mkdir -p "$MOSQUITTO_CONF_DIR"
        cp "$data_dir/mosquitto.conf" "$MOSQUITTO_CONF_FILE"
        log "restored mosquitto.conf"
        restored_files+=("mosquitto.conf")
    else
        log_warn "mosquitto.conf not found in backup"
    fi
    
    # 恢复密码文件
    if [ -f "$data_dir/passwd" ]; then
        cp "$data_dir/passwd" "$MOSQUITTO_PASSWD_FILE"
        chmod 600 "$MOSQUITTO_PASSWD_FILE"
        log "restored password file"
        restored_files+=("passwd")
    else
        log_warn "password file not found in backup"
    fi
    
    # 恢复持久化数据
    if [ -d "$data_dir/persistence" ]; then
        local persistence_dir="$TERMUX_VAR_DIR/lib/mosquitto"
        mkdir -p "$persistence_dir"
        
        # 备份现有持久化数据
        if [ -d "$persistence_dir" ] && [ "$(ls -A "$persistence_dir" 2>/dev/null)" ]; then
            local backup_persistence="$persistence_dir.backup.$(date +%Y%m%d_%H%M%S)"
            mv "$persistence_dir" "$backup_persistence"
            log "backed up existing persistence data to: $(basename "$backup_persistence")"
        fi
        
        mkdir -p "$persistence_dir"
        cp -r "$data_dir/persistence"/* "$persistence_dir/" 2>/dev/null || true
        log "restored persistence data"
        restored_files+=("persistence")
    else
        log_debug "no persistence data found in backup"
    fi
    
    # 恢复日志文件（可选）
    if [ -d "$data_dir/logs" ]; then
        mkdir -p "$MOSQUITTO_LOG_DIR"
        cp -r "$data_dir/logs"/* "$MOSQUITTO_LOG_DIR/" 2>/dev/null || true
        log "restored log files"
        restored_files+=("logs")
    else
        log_debug "no log files found in backup"
    fi
    
    log "restored files: ${restored_files[*]}"
    return 0
}

# -----------------------------------------------------------------------------
# 处理serviceupdate配置
# -----------------------------------------------------------------------------
handle_serviceupdate_config() {
    local extracted_dir="$1"
    
    # 查找serviceupdate配置文件
    local serviceupdate_config_file=""
    if [ -f "$extracted_dir/serviceupdate_config.json" ]; then
        serviceupdate_config_file="$extracted_dir/serviceupdate_config.json"
    else
        # 在子目录中查找
        serviceupdate_config_file=$(find "$extracted_dir" -name "serviceupdate_config.json" -type f | head -1)
    fi
    
    if [ -n "$serviceupdate_config_file" ] && [ -f "$serviceupdate_config_file" ]; then
        log "found serviceupdate configuration in backup"
        
        local backup_config=$(cat "$serviceupdate_config_file")
        
        # 检查当前serviceupdate.json中的配置是否与备份一致
        if [ -f "$SERVICEUPDATE_FILE" ]; then
            local current_config=$(jq -c ".services[] | select(.id==\"$SERVICE_ID\") | .config" "$SERVICEUPDATE_FILE" 2>/dev/null || echo "{}")
            
            if [ "$backup_config" != "$current_config" ]; then
                log "serviceupdate configuration differs from backup, applying current configuration"
                
                # 使用当前serviceupdate.json中的配置重新生成
                if generate_mosquitto_config_from_serviceupdate; then
                    log "regenerated configuration from current serviceupdate.json"
                else
                    log_warn "failed to regenerate configuration from serviceupdate.json"
                fi
                
                if update_users_from_serviceupdate; then
                    log "updated users from current serviceupdate.json"
                else
                    log_warn "failed to update users from serviceupdate.json"
                fi
            else
                log "serviceupdate configuration matches backup"
            fi
        else
            log_warn "serviceupdate.json not found, cannot compare configurations"
        fi
    else
        log_debug "no serviceupdate configuration found in backup"
    fi
    
    # 确保全局配置同步
    if sync_to_global_config; then
        log "synchronized configuration to configuration.yaml"
    else
        log_warn "failed to sync configuration to configuration.yaml"
    fi
}

# -----------------------------------------------------------------------------
# 确定恢复文件
# -----------------------------------------------------------------------------
determine_restore_file() {
    local restore_file=""
    local method=""
    local converted_from_zip=false
    
    if [ -n "$CUSTOM_BACKUP_FILE" ]; then
        restore_file="$CUSTOM_BACKUP_FILE"
        if [ -f "$restore_file" ]; then
            log "using user specified file: $restore_file"
            method="user_specified"
        else
            log_error "user specified file not found: $restore_file"
            mqtt_report "isg/restore/$SERVICE_ID/status" "{\"status\":\"failed\",\"message\":\"user specified file not found\",\"file\":\"$restore_file\",\"timestamp\":$(date +%s)}"
            return 1
        fi
    else
        restore_file=$(ls -1t "$BACKUP_DIR"/mosquitto_backup_*.tar.gz 2>/dev/null | head -n1 || true)
        if [ -n "$restore_file" ] && [ -f "$restore_file" ]; then
            log "using latest backup: $restore_file"
            method="latest_backup"
        else
            log "no backup file found, will generate default configuration"
            method="default_config"
            restore_file=""
        fi
    fi
    
    # 处理用户指定的文件格式
    if [ -n "$restore_file" ] && [ "$method" = "user_specified" ]; then
        local basename=$(basename "$restore_file")
        local ext="${basename##*.}"
        local ext_lower=$(echo "$ext" | tr '[:upper:]' '[:lower:]')
        
        if [ "$ext_lower" = "zip" ]; then
            log "detected ZIP file, converting to tar.gz format"
            local converted_file=$(process_zip_file "$restore_file" "$TEMP_DIR")
            if [ $? -eq 0 ] && [ -n "$converted_file" ]; then
                restore_file="$converted_file"
                converted_from_zip=true
                log "ZIP file converted successfully"
            else
                log_error "failed to convert ZIP file"
                return 1
            fi
        elif [ "$basename" != *.tar.gz ]; then
            log_error "unsupported file format: $ext (only .tar.gz and .zip are supported)"
            mqtt_report "isg/restore/$SERVICE_ID/status" "{\"status\":\"failed\",\"message\":\"unsupported file format. only .tar.gz and .zip are supported\",\"file\":\"$basename\",\"timestamp\":$(date +%s)}"
            return 1
        fi
        
        # 验证备份文件
        if ! validate_backup_file "$restore_file"; then
            return 1
        fi
    fi
    
    # 输出结果
    echo "$restore_file|$method|$converted_from_zip"
    return 0
}

# -----------------------------------------------------------------------------
# 主恢复流程
# -----------------------------------------------------------------------------
main_restore_process() {
    log "starting mosquitto restore process"
    mqtt_report "isg/restore/$SERVICE_ID/status" "{\"status\":\"restoring\",\"message\":\"starting restore process\",\"timestamp\":$(date +%s)}"
    
    # 确定恢复文件
    local restore_info=$(determine_restore_file)
    if [ $? -ne 0 ]; then
        return 1
    fi
    
    local restore_file=$(echo "$restore_info" | cut -d'|' -f1)
    local method=$(echo "$restore_info" | cut -d'|' -f2)
    local converted_from_zip=$(echo "$restore_info" | cut -d'|' -f3)
    
    # 处理无备份文件的情况 - 生成默认配置
    if [ -z "$restore_file" ] || [ "$method" = "default_config" ]; then
        log "no backup file found, generating default configuration"
        mqtt_report "isg/restore/$SERVICE_ID/status" "{\"status\":\"restoring\",\"method\":\"default_config\",\"timestamp\":$(date +%s)}"
        
        # 停止服务
        log "stopping mosquitto to release resources"
        bash "$SERVICE_DIR/stop.sh" || true
        sleep 5
        
        # 生成默认配置
        if ! generate_default_config; then
            mqtt_report "isg/restore/$SERVICE_ID/status" "{\"status\":\"failed\",\"message\":\"failed to generate default configuration\",\"method\":\"default_config\",\"timestamp\":$(date +%s)}"
            return 1
        fi
        
        # 启动服务验证配置
        bash "$SERVICE_DIR/start.sh"
        
        # 等待并验证服务状态
        local max_wait=120
        local interval=5
        local waited=0
        log "waiting for mosquitto to start with new configuration"
        
        while [ $waited -lt $max_wait ]; do
            if bash "$SERVICE_DIR/status.sh" --quiet; then
                log "service is running with new configuration after ${waited}s"
                break
            fi
            sleep "$interval"
            waited=$((waited + interval))
        done
        
        # 最终状态验证和上报
        if bash "$SERVICE_DIR/status.sh" --quiet; then
            local end_time=$(date +%s)
            local duration=$((end_time - START_TIME))
            mqtt_report "isg/restore/$SERVICE_ID/status" "{\"service\":\"$SERVICE_ID\",\"status\":\"success\",\"method\":\"default_config\",\"duration\":$duration,\"startup_time\":$waited,\"timestamp\":$end_time}"
            log "default configuration generated and service started successfully in ${duration}s (startup: ${waited}s)"
        else
            log_error "service failed to start with new configuration after ${max_wait}s"
            mqtt_report "isg/restore/$SERVICE_ID/status" "{\"status\":\"failed\",\"message\":\"service failed to start after config generation\",\"method\":\"default_config\",\"timestamp\":$(date +%s)}"
            return 1
        fi
        
        return 0
    fi
    
    # 处理备份文件还原
    log "starting restore from: $(basename "$restore_file")"
    
    # 上报开始还原
    if [ "$converted_from_zip" = true ]; then
        mqtt_report "isg/restore/$SERVICE_ID/status" "{\"status\":\"restoring\",\"method\":\"$method\",\"file\":\"$CUSTOM_BACKUP_FILE\",\"converting_zip\":true}"
    else
        mqtt_report "isg/restore/$SERVICE_ID/status" "{\"status\":\"restoring\",\"method\":\"$method\",\"file\":\"$(basename "$restore_file")\"}"
    fi
    
    # 停止服务
    log "stopping mosquitto before restore"
    bash "$SERVICE_DIR/stop.sh" || true
    sleep 5
    
    # 执行恢复
    local temp_extract_dir="$TEMP_DIR/extract_$$"
    mkdir -p "$temp_extract_dir"
    
    if tar -xzf "$restore_file" -C "$temp_extract_dir"; then
        log "backup file extracted successfully"
        
        # 恢复配置文件
        if ! restore_configuration_files "$temp_extract_dir"; then
            log_error "failed to restore configuration files"
            rm -rf "$temp_extract_dir"
            return 1
        fi
        
        # 处理serviceupdate配置
        handle_serviceupdate_config "$temp_extract_dir"
        
        # 清理临时目录
        rm -rf "$temp_extract_dir"
        
        log "restore completed, restarting service"
        bash "$SERVICE_DIR/start.sh"
        sleep 30
        
        if bash "$SERVICE_DIR/status.sh" --quiet; then
            local end_time=$(date +%s)
            local duration=$((end_time - START_TIME))
            local size_kb=$(du -k "$restore_file" | awk '{print $1}')
            
            # 构建成功消息
            if [ "$converted_from_zip" = true ]; then
                mqtt_report "isg/restore/$SERVICE_ID/status" "{\"service\":\"$SERVICE_ID\",\"status\":\"success\",\"method\":\"$method\",\"original_file\":\"$(basename "$CUSTOM_BACKUP_FILE")\",\"restore_file\":\"$(basename "$restore_file")\",\"size_kb\":$size_kb,\"duration\":$duration,\"converted_from_zip\":true,\"timestamp\":$end_time}"
                log "restore + restart complete: $(basename "$restore_file") ($size_kb KB, ${duration}s)"
                log "converted from: $(basename "$CUSTOM_BACKUP_FILE")"
            else
                mqtt_report "isg/restore/$SERVICE_ID/status" "{\"service\":\"$SERVICE_ID\",\"status\":\"success\",\"method\":\"$method\",\"file\":\"$(basename "$restore_file")\",\"size_kb\":$size_kb,\"duration\":$duration,\"timestamp\":$end_time}"
                log "restore + restart complete: $(basename "$restore_file") ($size_kb KB, ${duration}s)"
            fi
        else
            log_error "restore succeeded but service did not start"
            mqtt_report "isg/restore/$SERVICE_ID/status" "{\"status\":\"failed\",\"message\":\"service failed to start after restore\",\"method\":\"$method\",\"timestamp\":$(date +%s)}"
            return 1
        fi
    else
        log_error "failed to extract backup file"
        mqtt_report "isg/restore/$SERVICE_ID/status" "{\"status\":\"failed\",\"message\":\"restore failed - could not extract backup\",\"timestamp\":$(date +%s)}"
        rm -rf "$temp_extract_dir"
        return 1
    fi
    
    return 0
}

# -----------------------------------------------------------------------------
# 脚本入口点
# -----------------------------------------------------------------------------
if ! main_restore_process; then
    log_error "restore process failed"
    exit 1
fi

log "mosquitto restore completed successfully"
exit 0