#!/data/data/com.termux/files/usr/bin/bash
# =============================================================================
# Mosquitto 还原脚本
# 版本: v1.0.1
# 功能: 还原备份文件或生成默认配置文件，支持 tar.gz 和 zip 格式
# 修复: IPv4监听配置，MQTT上报时机控制
# =============================================================================

set -euo pipefail

# 加载统一路径定义
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/common_paths.sh" || {
    echo "Error: Cannot load common paths"
    exit 1
}

# 设置脚本特定的日志文件
LOG_FILE="$LOG_FILE_RESTORE"

# 确保必要目录存在
ensure_directories

START_TIME=$(date +%s)
CUSTOM_BACKUP_FILE="${RESTORE_FILE:-}"

# -----------------------------------------------------------------------------
# 生成默认配置文件（确保IPv4监听）
# -----------------------------------------------------------------------------
generate_default_config() {
    log "generating default configuration with IPv4 global listening"
    
    # 确保配置目录存在
    mkdir -p "$MOSQUITTO_CONF_DIR"
    mkdir -p "$MOSQUITTO_LOG_DIR"
    
    # 获取 MQTT 配置
    if ! load_mqtt_conf; then
        log_warn "failed to load MQTT config, using defaults"
        MQTT_USER="admin"
        MQTT_PASS="admin"
    fi
    
    # 生成优化的默认配置文件（IPv4全局监听）
    cat > "$MOSQUITTO_CONF_FILE" << EOF
# Mosquitto Configuration File
# Auto-generated by servicemanager restore script
# Generated on: $(date)
# Compatible with Mosquitto 2.0+

# IPv4 Network Settings - Listen on all interfaces
listener 1883 0.0.0.0

# WebSocket Support
listener 9001 0.0.0.0
protocol websockets

# Authentication
allow_anonymous false
password_file $MOSQUITTO_PASSWD_FILE

# Persistence
persistence true
persistence_location $TERMUX_VAR_DIR/lib/mosquitto/

# Logging
log_dest file $MOSQUITTO_LOG_DIR/mosquitto.log
log_type error
log_type warning
log_type notice
log_type information
log_timestamp true

# Security and Performance
max_connections 100
max_inflight_messages 20
max_queued_messages 100

# Client settings
persistent_client_expiration 1m
max_packet_size 100000000

# Connection settings
keepalive_interval 60
retry_interval 20
EOF
    
    # 验证配置文件
    if ! mosquitto -c "$MOSQUITTO_CONF_FILE" -t 2>/dev/null; then
        log_warn "advanced configuration failed, using minimal configuration"
        
        # 最简配置作为后备
        cat > "$MOSQUITTO_CONF_FILE" << EOF
# Mosquitto Minimal Configuration
listener 1883 0.0.0.0
allow_anonymous false
password_file $MOSQUITTO_PASSWD_FILE
persistence true
persistence_location $TERMUX_VAR_DIR/lib/mosquitto/
log_dest file $MOSQUITTO_LOG_DIR/mosquitto.log
EOF
        
        if ! mosquitto -c "$MOSQUITTO_CONF_FILE" -t 2>/dev/null; then
            log_error "even minimal configuration validation failed"
            return 1
        fi
    fi
    
    # 创建管理员用户
    if echo "$MQTT_USER:$MQTT_PASS" | mosquitto_passwd -c "$MOSQUITTO_PASSWD_FILE" "$MQTT_USER"; then
        chmod 600 "$MOSQUITTO_PASSWD_FILE"
        log "default user created: $MQTT_USER"
    else
        log_error "failed to create default user"
        return 1
    fi
    
    log "default configuration generated successfully with IPv4 global listening"
    return 0
}

# -----------------------------------------------------------------------------
# 检测和处理ZIP文件
# -----------------------------------------------------------------------------
process_zip_file() {
    local zip_file="$1"
    local output_dir="$2"
    
    log "processing ZIP file: $(basename "$zip_file")"
    
    # 创建临时解压目录
    local temp_extract_dir="$TEMP_DIR/zip_extract_$$"
    mkdir -p "$temp_extract_dir"
    
    # 解压ZIP文件
    if ! unzip -q "$zip_file" -d "$temp_extract_dir"; then
        log_error "failed to extract ZIP file: $(basename "$zip_file")"
        rm -rf "$temp_extract_dir"
        return 1
    fi
    
    # 查找有效的mosquitto数据结构
    local data_dir_in_zip=""
    
    # 检查直接包含配置文件的情况
    if [ -f "$temp_extract_dir/mosquitto.conf" ]; then
        data_dir_in_zip="."
        log_debug "found mosquitto.conf in ZIP root"
    else
        # 查找backup_*目录
        local backup_dirs=$(find "$temp_extract_dir" -name "backup_*" -type d | head -1)
        if [ -n "$backup_dirs" ]; then
            data_dir_in_zip=$(basename "$backup_dirs")
            log_debug "found backup directory: $data_dir_in_zip"
        else
            # 查找包含mosquitto.conf的任何目录
            local conf_path=$(find "$temp_extract_dir" -name "mosquitto.conf" -type f | head -1)
            if [ -n "$conf_path" ]; then
                data_dir_in_zip=$(dirname "$conf_path" | sed "s|$temp_extract_dir/||")
                log_debug "found mosquitto.conf in: $data_dir_in_zip"
            fi
        fi
    fi
    
    if [ -z "$data_dir_in_zip" ]; then
        log_error "no valid mosquitto data found in ZIP file"
        rm -rf "$temp_extract_dir"
        return 1
    fi
    
    # 创建标准tar.gz格式
    local converted_file="$BACKUP_DIR/mosquitto_converted_$(date +%Y%m%d_%H%M%S).tar.gz"
    
    if [ "$data_dir_in_zip" = "." ]; then
        # 直接打包整个临时目录
        if tar -czf "$converted_file" -C "$temp_extract_dir" .; then
            log "ZIP converted to tar.gz: $(basename "$converted_file")"
        else
            log_error "failed to create tar.gz from ZIP"
            rm -rf "$temp_extract_dir"
            return 1
        fi
    else
        # 打包指定的数据目录
        if tar -czf "$converted_file" -C "$temp_extract_dir" "$data_dir_in_zip"; then
            log "ZIP converted to tar.gz: $(basename "$converted_file")"
        else
            log_error "failed to create tar.gz from ZIP"
            rm -rf "$temp_extract_dir"
            return 1
        fi
    fi
    
    # 清理临时目录
    rm -rf "$temp_extract_dir"
    
    # 返回转换后的文件路径
    echo "$converted_file"
    return 0
}

# -----------------------------------------------------------------------------
# 验证备份文件完整性
# -----------------------------------------------------------------------------
validate_backup_file() {
    local backup_file="$1"
    
    log "validating backup file: $(basename "$backup_file")"
    
    # 检查文件是否存在且可读
    if [ ! -f "$backup_file" ] || [ ! -r "$backup_file" ]; then
        log_error "backup file not found or not readable: $backup_file"
        return 1
    fi
    
    # 检查文件大小
    local file_size=$(du -k "$backup_file" | cut -f1)
    if [ "$file_size" -lt 1 ]; then
        log_error "backup file is empty: $backup_file"
        return 1
    fi
    
    # 检查tar.gz文件完整性
    if ! tar -tzf "$backup_file" >/dev/null 2>&1; then
        log_error "backup file is corrupted or invalid: $backup_file"
        return 1
    fi
    
    # 检查是否包含关键文件
    local has_mosquitto_conf=false
    if tar -tzf "$backup_file" | grep -q "mosquitto.conf$"; then
        has_mosquitto_conf=true
    fi
    
    if [ "$has_mosquitto_conf" = false ]; then
        log_warn "backup file does not contain mosquitto.conf"
        # 不是致命错误，可能是部分备份
    fi
    
    log "backup file validation passed"
    return 0
}

# -----------------------------------------------------------------------------
# 还原配置文件（确保IPv4监听）
# -----------------------------------------------------------------------------
restore_configuration_files() {
    local extracted_dir="$1"
    local restored_files=()
    
    log "restoring configuration files from: $extracted_dir"
    
    # 查找提取的数据目录
    local data_dir="$extracted_dir"
    if [ ! -f "$data_dir/mosquitto.conf" ]; then
        # 查找包含配置文件的子目录
        local subdirs=$(find "$extracted_dir" -name "mosquitto.conf" -type f | head -1)
        if [ -n "$subdirs" ]; then
            data_dir=$(dirname "$subdirs")
            log_debug "found data in subdirectory: $data_dir"
        fi
    fi
    
    # 恢复主配置文件
    if [ -f "$data_dir/mosquitto.conf" ]; then
        mkdir -p "$MOSQUITTO_CONF_DIR"
        cp "$data_dir/mosquitto.conf" "$MOSQUITTO_CONF_FILE"
        
        # 验证和修复配置文件以确保IPv4监听
        if ! mosquitto -c "$MOSQUITTO_CONF_FILE" -t 2>/dev/null; then
            log_warn "restored configuration failed validation, regenerating with IPv4 support"
            generate_default_config
        else
            # 检查是否有IPv4监听配置
            if ! grep -q "listener.*1883.*0.0.0.0" "$MOSQUITTO_CONF_FILE" && 
               ! grep -q "port.*1883" "$MOSQUITTO_CONF_FILE"; then
                log_warn "restored config may not have IPv4 listening, adding listener configuration"
                
                # 备份原配置
                cp "$MOSQUITTO_CONF_FILE" "$MOSQUITTO_CONF_FILE.restored.$(date +%Y%m%d_%H%M%S)"
                
                # 在配置文件开头添加IPv4监听
                local temp_config="$MOSQUITTO_CONF_FILE.tmp"
                cat > "$temp_config" << EOF
# IPv4 Global Listening - Added by restore process
listener 1883 0.0.0.0

EOF
                cat "$MOSQUITTO_CONF_FILE" >> "$temp_config"
                mv "$temp_config" "$MOSQUITTO_CONF_FILE"
                
                log "added IPv4 global listening to restored configuration"
            fi
        fi
        
        log "restored mosquitto.conf with IPv4 listening verification"
        restored_files+=("mosquitto.conf")
    else
        log_warn "mosquitto.conf not found in backup, generating default"
        generate_default_config
        restored_files+=("mosquitto.conf (generated)")
    fi
    
    # 恢复密码文件
    if [ -f "$data_dir/passwd" ]; then
        cp "$data_dir/passwd" "$MOSQUITTO_PASSWD_FILE"
        chmod 600 "$MOSQUITTO_PASSWD_FILE"
        log "restored password file"
        restored_files+=("passwd")
    else
        log_warn "password file not found in backup, using current configuration"
    fi
    
    # 恢复持久化数据
    if [ -d "$data_dir/persistence" ]; then
        local persistence_dir="$TERMUX_VAR_DIR/lib/mosquitto"
        mkdir -p "$persistence_dir"
        
        # 备份现有持久化数据
        if [ -d "$persistence_dir" ] && [ "$(ls -A "$persistence_dir" 2>/dev/null)" ]; then
            local backup_persistence="$persistence_dir.backup.$(date +%Y%m%d_%H%M%S)"
            mv "$persistence_dir" "$backup_persistence"
            log "backed up existing persistence data to: $(basename "$backup_persistence")"
        fi
        
        mkdir -p "$persistence_dir"
        cp -r "$data_dir/persistence"/* "$persistence_dir/" 2>/dev/null || true
        log "restored persistence data"
        restored_files+=("persistence")
    else
        log_debug "no persistence data found in backup"
    fi
    
    # 恢复日志文件（可选）
    if [ -d "$data_dir/logs" ]; then
        mkdir -p "$MOSQUITTO_LOG_DIR"
        cp -r "$data_dir/logs"/* "$MOSQUITTO_LOG_DIR/" 2>/dev/null || true
        log "restored log files"
        restored_files+=("logs")
    else
        log_debug "no log files found in backup"
    fi
    
    log "restored files: ${restored_files[*]}"
    return 0
}

# -----------------------------------------------------------------------------
# 处理serviceupdate配置
# -----------------------------------------------------------------------------
handle_serviceupdate_config() {
    local extracted_dir="$1"
    
    # 查找serviceupdate配置文件
    local serviceupdate_config_file=""
    if [ -f "$extracted_dir/serviceupdate_config.json" ]; then
        serviceupdate_config_file="$extracted_dir/serviceupdate_config.json"
    else
        # 在子目录中查找
        serviceupdate_config_file=$(find "$extracted_dir" -name "serviceupdate_config.json" -type f | head -1)
    fi
    
    if [ -n "$serviceupdate_config_file" ] && [ -f "$serviceupdate_config_file" ]; then
        log "found serviceupdate configuration in backup"
        
        local backup_config=$(cat "$serviceupdate_config_file")
        
        # 检查当前serviceupdate.json中的配置是否与备份一致
        if [ -f "$SERVICEUPDATE_FILE" ]; then
            local current_config=$(jq -c ".services[] | select(.id==\"$SERVICE_ID\") | .config" "$SERVICEUPDATE_FILE" 2>/dev/null || echo "{}")
            
            if [ "$backup_config" != "$current_config" ]; then
                log "serviceupdate configuration differs from backup, applying current configuration"
                
                # 使用当前serviceupdate.json中的配置重新生成
                if generate_mosquitto_config_from_serviceupdate; then
                    log "regenerated configuration from current serviceupdate.json"
                else
                    log_warn "failed to regenerate configuration from serviceupdate.json"
                fi
                
                if update_users_from_serviceupdate; then
                    log "updated users from current serviceupdate.json"
                else
                    log_warn "failed to update users from serviceupdate.json"
                fi
            else
                log "serviceupdate configuration matches backup"
            fi
        else
            log_warn "serviceupdate.json not found, cannot compare configurations"
        fi
    else
        log_debug "no serviceupdate configuration found in backup"
    fi
    
    # 确保全局配置同步
    if sync_to_global_config; then
        log "synchronized configuration to configuration.yaml"
    else
        log_warn "failed to sync configuration to configuration.yaml"
    fi
}

# -----------------------------------------------------------------------------
# 确定恢复文件
# -----------------------------------------------------------------------------
determine_restore_file() {
    local restore_file=""
    local method=""
    local converted_from_zip=false
    
    if [ -n "$CUSTOM_BACKUP_FILE" ]; then
        restore_file="$CUSTOM_BACKUP_FILE"
        if [ -f "$restore_file" ]; then
            log "using user specified file: $restore_file"
            method="user_specified"
        else
            log_error "user specified file not found: $restore_file"
            return 1
        fi
    else
        restore_file=$(ls -1t "$BACKUP_DIR"/mosquitto_backup_*.tar.gz 2>/dev/null | head -n1 || true)
        if [ -n "$restore_file" ] && [ -f "$restore_file" ]; then
            log "using latest backup: $restore_file"
            method="latest_backup"
        else
            log "no backup file found, will generate default configuration"
            method="default_config"
            restore_file=""
        fi
    fi
    
    # 处理用户指定的文件格式
    if [ -n "$restore_file" ] && [ "$method" = "user_specified" ]; then
        local basename=$(basename "$restore_file")
        local ext="${basename##*.}"
        local ext_lower=$(echo "$ext" | tr '[:upper:]' '[:lower:]')
        
        if [ "$ext_lower" = "zip" ]; then
            log "detected ZIP file, converting to tar.gz format"
            local converted_file=$(process_zip_file "$restore_file" "$TEMP_DIR")
            if [ $? -eq 0 ] && [ -n "$converted_file" ]; then
                restore_file="$converted_file"
                converted_from_zip=true
                log "ZIP file converted successfully"
            else
                log_error "failed to convert ZIP file"
                return 1
            fi
        elif [ "$basename" != *.tar.gz ]; then
            log_error "unsupported file format: $ext (only .tar.gz and .zip are supported)"
            return 1
        fi
        
        # 验证备份文件
        if ! validate_backup_file "$restore_file"; then
            return 1
        fi
    fi
    
    # 输出结果
    echo "$restore_file|$method|$converted_from_zip"
    return 0
}

# -----------------------------------------------------------------------------
# 验证服务启动和IPv4监听
# -----------------------------------------------------------------------------
verify_service_ipv4_listening() {
    local max_wait="$1"
    local check_interval="${2:-5}"
    local waited=0
    
    log "verifying service startup and IPv4 listening (max wait: ${max_wait}s)"
    
    while [ $waited -lt $max_wait ]; do
        # 检查进程
        if MOSQUITTO_PID=$(get_mosquitto_pid); then
            log_debug "mosquitto process found (PID: $MOSQUITTO_PID)"
            
            # 验证IPv4监听
            if netstat -tulnp 2>/dev/null | grep -q "0.0.0.0:1883"; then
                log "SUCCESS: mosquitto listening on 0.0.0.0:1883 after ${waited}s"
                
                # 检查WebSocket端口
                if netstat -tulnp 2>/dev/null | grep -q "0.0.0.0:9001"; then
                    log "SUCCESS: mosquitto WebSocket listening on 0.0.0.0:9001"
                else
                    log_warn "WebSocket port 9001 not listening on IPv4, but main port OK"
                fi
                
                return 0
            else
                log_debug "process exists but not listening on IPv4 yet (${waited}s)"
            fi
        else
            log_debug "waiting for mosquitto process (${waited}s)"
        fi
        
        sleep "$check_interval"
        waited=$((waited + check_interval))
    done
    
    log_error "service failed to achieve IPv4 listening after ${max_wait}s"
    
    # 诊断信息
    log "=== IPv4 LISTENING DIAGNOSTIC ==="
    log "Current processes:"
    ps aux | grep mosquitto | grep -v grep >> "$LOG_FILE" || echo "No mosquitto processes" >> "$LOG_FILE"
    
    log "Current network listening:"
    netstat -tulnp 2>/dev/null | grep -E "(1883|9001)" >> "$LOG_FILE" || echo "No mosquitto ports" >> "$LOG_FILE"
    
    return 1
}

# -----------------------------------------------------------------------------
# 主恢复流程
# -----------------------------------------------------------------------------
main_restore_process() {
    log "starting mosquitto restore process"
    
    # 初始状态不上报MQTT（可能服务不可用）
    echo "[$(date '+%F %T')] [INFO] Starting restore process" >> "$LOG_FILE"
    
    # 确定恢复文件
    local restore_info=$(determine_restore_file)
    if [ $? -ne 0 ]; then
        return 1
    fi
    
    local restore_file=$(echo "$restore_info" | cut -d'|' -f1)
    local method=$(echo "$restore_info" | cut -d'|' -f2)
    local converted_from_zip=$(echo "$restore_info" | cut -d'|' -f3)
    
    # 处理无备份文件的情况 - 生成默认配置
    if [ -z "$restore_file" ] || [ "$method" = "default_config" ]; then
        log "no backup file found, generating default configuration with IPv4 listening"
        
        # 停止服务
        log "stopping mosquitto to release resources"
        bash "$SERVICE_DIR/stop.sh" || true
        sleep 5
        
        # 生成默认配置
        if ! generate_default_config; then
            log_error "failed to generate default configuration"
            return 1
        fi
        
        # 启动服务验证配置
        bash "$SERVICE_DIR/start.sh"
        
        # 验证IPv4监听
        if verify_service_ipv4_listening 120 5; then
            local end_time=$(date +%s)
            local duration=$((end_time - START_TIME))
            local startup_time=$((duration - 5))  # 减去停止等待时间
            
            log "default configuration generated and IPv4 listening verified successfully"
            
            # 现在服务运行中，可以安全上报MQTT
            mqtt_report "isg/restore/$SERVICE_ID/status" \
                "{\"service\":\"$SERVICE_ID\",\"status\":\"success\",\"method\":\"default_config\",\"duration\":$duration,\"startup_time\":$startup_time,\"ipv4_listening\":true,\"timestamp\":$end_time}" \
                3 2>/dev/null || log "MQTT success report failed"
        else
            log_error "service failed to start with IPv4 listening after default config generation"
            
            # 尝试上报失败状态（使用其他MQTT服务）
            (
                sleep 2
                mqtt_report "isg/restore/$SERVICE_ID/status" \
                    "{\"status\":\"failed\",\"message\":\"service failed to start with IPv4 listening after config generation\",\"method\":\"default_config\",\"timestamp\":$(date +%s)}" \
                    1 2>/dev/null || true
            ) &
            
            return 1
        fi
        
        return 0
    fi
    
    # 处理备份文件还原
    log "starting restore from: $(basename "$restore_file")"
    
    # 停止服务
    log "stopping mosquitto before restore"
    bash "$SERVICE_DIR/stop.sh" || true
    sleep 5
    
    # 执行恢复
    local temp_extract_dir="$TEMP_DIR/extract_$"
    mkdir -p "$temp_extract_dir"
    
    if tar -xzf "$restore_file" -C "$temp_extract_dir"; then
        log "backup file extracted successfully"
        
        # 恢复配置文件
        if ! restore_configuration_files "$temp_extract_dir"; then
            log_error "failed to restore configuration files"
            rm -rf "$temp_extract_dir"
            return 1
        fi
        
        # 处理serviceupdate配置
        handle_serviceupdate_config "$temp_extract_dir"
        
        # 清理临时目录
        rm -rf "$temp_extract_dir"
        
        log "restore completed, restarting service"
        bash "$SERVICE_DIR/start.sh"
        
        # 验证IPv4监听
        if verify_service_ipv4_listening 60 5; then
            local end_time=$(date +%s)
            local duration=$((end_time - START_TIME))
            local size_kb=$(du -k "$restore_file" | awk '{print $1}')
            
            log "restore completed successfully with IPv4 listening verified"
            
            # 构建成功消息
            if [ "$converted_from_zip" = true ]; then
                mqtt_report "isg/restore/$SERVICE_ID/status" \
                    "{\"service\":\"$SERVICE_ID\",\"status\":\"success\",\"method\":\"$method\",\"original_file\":\"$(basename "$CUSTOM_BACKUP_FILE")\",\"restore_file\":\"$(basename "$restore_file")\",\"size_kb\":$size_kb,\"duration\":$duration,\"converted_from_zip\":true,\"ipv4_listening\":true,\"timestamp\":$end_time}" \
                    3 2>/dev/null || log "MQTT success report failed"
                
                log "restore complete: $(basename "$restore_file") ($size_kb KB, ${duration}s)"
                log "converted from: $(basename "$CUSTOM_BACKUP_FILE")"
            else
                mqtt_report "isg/restore/$SERVICE_ID/status" \
                    "{\"service\":\"$SERVICE_ID\",\"status\":\"success\",\"method\":\"$method\",\"file\":\"$(basename "$restore_file")\",\"size_kb\":$size_kb,\"duration\":$duration,\"ipv4_listening\":true,\"timestamp\":$end_time}" \
                    3 2>/dev/null || log "MQTT success report failed"
                
                log "restore complete: $(basename "$restore_file") ($size_kb KB, ${duration}s)"
            fi
        else
            log_error "restore succeeded but service failed to achieve IPv4 listening"
            
            (
                sleep 2
                mqtt_report "isg/restore/$SERVICE_ID/status" \
                    "{\"status\":\"failed\",\"message\":\"service failed to start with IPv4 listening after restore\",\"method\":\"$method\",\"timestamp\":$(date +%s)}" \
                    1 2>/dev/null || true
            ) &
            
            return 1
        fi
    else
        log_error "failed to extract backup file"
        rm -rf "$temp_extract_dir"
        
        (
            sleep 1
            mqtt_report "isg/restore/$SERVICE_ID/status" \
                "{\"status\":\"failed\",\"message\":\"restore failed - could not extract backup\",\"timestamp\":$(date +%s)}" \
                1 2>/dev/null || true
        ) &
        
        return 1
    fi
    
    return 0
}

# -----------------------------------------------------------------------------
# 脚本入口点
# -----------------------------------------------------------------------------
if ! main_restore_process; then
    log_error "restore process failed"
    exit 1
fi

log "mosquitto restore completed successfully with IPv4 listening verified"
exit 0