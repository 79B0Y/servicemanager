#!/Users/boyao/isg/.venv/bin/python
"""
iSG App Guardian - è½»é‡çº§åº”ç”¨ç›‘æ§å®ˆæŠ¤æœåŠ¡

ä¸“ä¸ºTermuxç¯å¢ƒè®¾è®¡çš„iSG Androidåº”ç”¨ç›‘æ§å·¥å…·
ç›‘æ§åº”ç”¨è¿›ç¨‹çŠ¶æ€ã€æ£€æµ‹å´©æºƒã€è®°å½•æ—¥å¿—å¹¶è‡ªåŠ¨é‡å¯åº”ç”¨

ä½¿ç”¨æ–¹æ³•:
    isg-guardian start      # å¯åŠ¨å®ˆæŠ¤æœåŠ¡
    isg-guardian stop       # åœæ­¢å®ˆæŠ¤æœåŠ¡  
    isg-guardian restart    # é‡å¯å®ˆæŠ¤æœåŠ¡
    isg-guardian status     # æŸ¥çœ‹è¿è¡ŒçŠ¶æ€
    isg-guardian logs       # æŸ¥çœ‹å®æ—¶æ—¥å¿—
    isg-guardian --help     # æ˜¾ç¤ºå¸®åŠ©ä¿¡æ¯
    isg-guardian --version  # æ˜¾ç¤ºç‰ˆæœ¬ä¿¡æ¯
"""

import os
import sys
import time
import signal
import asyncio
import argparse

try:
    import yaml
except ImportError:
    print("âŒ é”™è¯¯: ç¼ºå°‘å¿…éœ€çš„PythonåŒ… 'yaml'")
    print("è¯·è¿è¡Œ: pip install PyYAML")
    sys.exit(1)
from pathlib import Path
from datetime import datetime
from typing import Optional

# è®¾ç½®è¿›ç¨‹åç§°ï¼Œä¾¿äºè¯†åˆ«å’Œç®¡ç†
try:
    import setproctitle
    setproctitle.setproctitle("iSG App Guardian")
except ImportError:
    print("è­¦å‘Š: setproctitleæœªå®‰è£…ï¼Œè¿›ç¨‹åç§°å°†æ˜¾ç¤ºä¸ºpython")

# æ·»åŠ srcç›®å½•åˆ°Pythonè·¯å¾„
sys.path.insert(0, os.path.join(os.path.dirname(__file__), 'src'))

# å¯¼å…¥æ ¸å¿ƒæ¨¡å—
try:
    from monitor import ProcessMonitor
    from logger import CrashLogger  
    from guardian import AppGuardian
    from mqtt_publisher import MQTTPublisher
except ImportError as e:
    print(f"âŒ å¯¼å…¥æ¨¡å—å¤±è´¥: {e}")
    print("è¯·ç¡®ä¿æ‰€æœ‰å¿…éœ€çš„PythonåŒ…å·²å®‰è£…: pip install -r requirements.txt")
    sys.exit(1)

# ç‰ˆæœ¬ä¿¡æ¯
VERSION = "2.0.0"


class ISGGuardian:
    """iSG Guardian ä¸»æ§åˆ¶å™¨ç±»"""
    
    def __init__(self):
        """åˆå§‹åŒ–Guardianå®ä¾‹"""
        # è®¾ç½®å·¥ä½œç›®å½•
        self.work_dir = Path(__file__).parent.absolute()
        os.chdir(self.work_dir)
        
        # åˆ›å»ºå¿…è¦ç›®å½•
        (self.work_dir / 'data' / 'crash_logs').mkdir(parents=True, exist_ok=True)
        (self.work_dir / 'data' / 'exports').mkdir(parents=True, exist_ok=True)
        
        # æ–‡ä»¶è·¯å¾„
        self.pid_file = self.work_dir / 'data' / 'guardian.pid'
        self.log_file = self.work_dir / 'data' / 'guardian.log'
        self.config_file = self.work_dir / 'config.yaml'
        
        # åŠ è½½é…ç½®
        self.config = self._load_config()
        
        # åˆå§‹åŒ–ç»„ä»¶
        self.monitor = ProcessMonitor(self.config)
        self.logger = CrashLogger(self.config)
        self.app_guardian = AppGuardian(self.config)
        self.mqtt = MQTTPublisher(self.config) if self.config['mqtt']['enabled'] else None
        self.running = False
        
    def _load_config(self) -> dict:
        """åŠ è½½é…ç½®æ–‡ä»¶
        
        Returns:
            dict: é…ç½®å­—å…¸
            
        Raises:
            SystemExit: é…ç½®æ–‡ä»¶ä¸å­˜åœ¨æˆ–æ ¼å¼é”™è¯¯
        """
        try:
            with open(self.config_file, 'r', encoding='utf-8') as f:
                return yaml.safe_load(f)
        except FileNotFoundError:
            self._print_error(f"é…ç½®æ–‡ä»¶ä¸å­˜åœ¨: {self.config_file}")
            print("è¯·å…ˆè¿è¡Œ: cp config.yaml.example config.yaml")
            sys.exit(1)
        except yaml.YAMLError as e:
            self._print_error(f"é…ç½®æ–‡ä»¶æ ¼å¼é”™è¯¯: {e}")
            sys.exit(1)
    
    def _check_dependencies(self) -> bool:
        """æ£€æŸ¥ç³»ç»Ÿä¾èµ–
        
        Returns:
            bool: ä¾èµ–æ£€æŸ¥æ˜¯å¦é€šè¿‡
        """
        missing_deps = []
        
        # æ£€æŸ¥adb
        if os.system("which adb > /dev/null 2>&1") != 0:
            missing_deps.append("adb (å®‰è£…: pkg install android-tools)")
            
        # æ£€æŸ¥mosquitto_pub (å¦‚æœå¯ç”¨MQTT)
        if self.config['mqtt']['enabled']:
            if os.system("which mosquitto_pub > /dev/null 2>&1") != 0:
                missing_deps.append("mosquitto_pub (å®‰è£…: pkg install mosquitto)")
        
        if missing_deps:
            self._print_error("ç¼ºå°‘ç³»ç»Ÿä¾èµ–:")
            for dep in missing_deps:
                print(f"  âŒ {dep}")
            return False
            
        # æ£€æŸ¥Androidè®¾å¤‡è¿æ¥
        result = os.system("adb devices 2>/dev/null | grep -q device")
        if result != 0:
            self._print_error("æ²¡æœ‰æ£€æµ‹åˆ°Androidè®¾å¤‡")
            print("  è¯·ç¡®ä¿:")
            print("  1. è®¾å¤‡å·²é€šè¿‡USBè¿æ¥")
            print("  2. å·²å¯ç”¨å¼€å‘è€…é€‰é¡¹å’ŒUSBè°ƒè¯•")
            print("  3. å·²æˆæƒæ­¤è®¡ç®—æœºçš„è°ƒè¯•è®¿é—®")
            return False
            
        return True
    
    def start_daemon(self) -> bool:
        """å¯åŠ¨å®ˆæŠ¤æœåŠ¡
        
        Returns:
            bool: å¯åŠ¨æ˜¯å¦æˆåŠŸ
        """
        # æ£€æŸ¥æ˜¯å¦å·²ç»åœ¨è¿è¡Œ
        if self._is_running():
            pid = self._get_running_pid()
            self._print_error(f"å®ˆæŠ¤æœåŠ¡å·²åœ¨è¿è¡Œ (PID: {pid})")
            return False
            
        # æ£€æŸ¥ä¾èµ–
        print("ğŸ”§ æ£€æŸ¥ç³»ç»Ÿä¾èµ–...")
        if not self._check_dependencies():
            return False
        print("âœ… ä¾èµ–æ£€æŸ¥å®Œæˆ")
        
        # å¯åŠ¨å®ˆæŠ¤è¿›ç¨‹
        print("ğŸš€ å¯åŠ¨ iSG App Guardian...")
        
        try:
            # åå°è¿è¡Œ
            pid = os.fork()
            if pid > 0:
                # çˆ¶è¿›ç¨‹ - ç­‰å¾…å­è¿›ç¨‹å¯åŠ¨å¹¶ä¿å­˜PID
                time.sleep(2)
                if self._is_running():
                    print(f"âœ… å®ˆæŠ¤æœåŠ¡å¯åŠ¨æˆåŠŸ (PID: {pid})")
                    print(f"   ğŸ“‹ è¿›ç¨‹åç§°: iSG App Guardian")
                    print(f"   ğŸ“ å·¥ä½œç›®å½•: {self.work_dir}")
                    print(f"   ğŸ“¡ ç›‘æ§ç›®æ ‡: {self.config['app']['package_name']}")
                    print()
                    print("ğŸ“Š ç®¡ç†å‘½ä»¤:")
                    print("   æŸ¥çœ‹çŠ¶æ€: isg-guardian status")
                    print("   æŸ¥çœ‹æ—¥å¿—: isg-guardian logs")
                    print("   åœæ­¢æœåŠ¡: isg-guardian stop")
                    return True
                else:
                    self._print_error("å®ˆæŠ¤æœåŠ¡å¯åŠ¨å¤±è´¥ï¼Œè¯·æŸ¥çœ‹æ—¥å¿—")
                    return False
            else:
                # å­è¿›ç¨‹ - æˆä¸ºå®ˆæŠ¤è¿›ç¨‹
                self._daemonize()
                
        except OSError as e:
            self._print_error(f"å¯åŠ¨å®ˆæŠ¤è¿›ç¨‹å¤±è´¥: {e}")
            return False
    
    def _daemonize(self):
        """å®ˆæŠ¤è¿›ç¨‹åŒ–"""
        # è„±ç¦»ç»ˆç«¯
        os.setsid()
        
        # é‡å®šå‘æ ‡å‡†è¾“å…¥è¾“å‡º
        with open('/dev/null', 'r') as f:
            os.dup2(f.fileno(), sys.stdin.fileno())
            
        with open(self.log_file, 'a') as f:
            os.dup2(f.fileno(), sys.stdout.fileno())
            os.dup2(f.fileno(), sys.stderr.fileno())
        
        # ä¿å­˜PID
        with open(self.pid_file, 'w') as f:
            f.write(str(os.getpid()))
        
        # è®¾ç½®ä¿¡å·å¤„ç†
        signal.signal(signal.SIGTERM, self._signal_handler)
        signal.signal(signal.SIGINT, self._signal_handler)
        
        # å¯åŠ¨ç›‘æ§å¾ªç¯
        try:
            asyncio.run(self._run_guardian())
        except Exception as e:
            print(f"âŒ å®ˆæŠ¤æœåŠ¡å¼‚å¸¸é€€å‡º: {e}")
        finally:
            self._cleanup()
    
    async def _run_guardian(self):
        """è¿è¡Œå®ˆæŠ¤æœåŠ¡ä¸»å¾ªç¯"""
        print(f"ğŸš€ iSG App Guardian å¯åŠ¨ - {datetime.now()}")
        
        # å¯åŠ¨å„ç»„ä»¶
        await self.logger.start()
        await self.monitor.start()
        await self.app_guardian.start()
        
        if self.mqtt:
            await self.mqtt.setup_discovery()
            
        self.running = True
        print("âœ… æ‰€æœ‰ç»„ä»¶å¯åŠ¨å®Œæˆ")
        
        # ä¸»ç›‘æ§å¾ªç¯
        try:
            while self.running:
                await self._monitor_cycle()
                await asyncio.sleep(self.config['monitor']['check_interval'])
        except Exception as e:
            print(f"âŒ ç›‘æ§å¾ªç¯å¼‚å¸¸: {e}")
        finally:
            print("ğŸ›‘ å®ˆæŠ¤æœåŠ¡æ­£åœ¨åœæ­¢...")
            
    async def _monitor_cycle(self):
        """å•æ¬¡ç›‘æ§å‘¨æœŸ"""
        try:
            # æ£€æŸ¥åº”ç”¨çŠ¶æ€
            app_status = await self.monitor.check_app_status()
            
            # è®°å½•çŠ¶æ€æ—¥å¿—
            await self.logger.log_status(app_status)
            
            # å‘å¸ƒMQTTçŠ¶æ€
            if self.mqtt:
                await self.mqtt.publish_status(app_status)
                
            # å¤„ç†å¼‚å¸¸çŠ¶æ€
            if app_status.crashed:
                await self.app_guardian.handle_crash(app_status)
                if self.mqtt:
                    await self.mqtt.publish_crash_alert("crash_detected", "åº”ç”¨å´©æºƒ")
            elif not app_status.running:
                await self.app_guardian.start_app()
                
        except Exception as e:
            print(f"âŒ ç›‘æ§å‘¨æœŸå¼‚å¸¸: {e}")
    
    def stop_daemon(self) -> bool:
        """åœæ­¢å®ˆæŠ¤æœåŠ¡
        
        Returns:
            bool: åœæ­¢æ˜¯å¦æˆåŠŸ
        """
        if not self._is_running():
            self._print_error("å®ˆæŠ¤æœåŠ¡æœªåœ¨è¿è¡Œ")
            return False
            
        pid = self._get_running_pid()
        print(f"ğŸ›‘ æ­£åœ¨åœæ­¢å®ˆæŠ¤æœåŠ¡ (PID: {pid})...")
        
        try:
            # å‘é€TERMä¿¡å·
            os.kill(pid, signal.SIGTERM)
            
            # ç­‰å¾…è¿›ç¨‹é€€å‡º
            for i in range(30):  # æœ€å¤šç­‰å¾…30ç§’
                if not self._is_running():
                    print("âœ… å®ˆæŠ¤æœåŠ¡å·²åœæ­¢")
                    return True
                time.sleep(1)
                
            # å¼ºåˆ¶æ€æ­»
            print("âš¡ å¼ºåˆ¶åœæ­¢è¿›ç¨‹...")
            os.kill(pid, signal.SIGKILL)
            time.sleep(2)
            
            if not self._is_running():
                print("âœ… å®ˆæŠ¤æœåŠ¡å·²å¼ºåˆ¶åœæ­¢")
                return True
            else:
                self._print_error("æ— æ³•åœæ­¢å®ˆæŠ¤æœåŠ¡")
                return False
                
        except ProcessLookupError:
            # è¿›ç¨‹å·²ç»ä¸å­˜åœ¨
            self._cleanup()
            print("âœ… å®ˆæŠ¤æœåŠ¡å·²åœæ­¢")
            return True
        except PermissionError:
            self._print_error("æƒé™ä¸è¶³ï¼Œæ— æ³•åœæ­¢å®ˆæŠ¤æœåŠ¡")
            return False
        except Exception as e:
            self._print_error(f"åœæ­¢å®ˆæŠ¤æœåŠ¡æ—¶å‘ç”Ÿé”™è¯¯: {e}")
            return False
    
    def restart_daemon(self) -> bool:
        """é‡å¯å®ˆæŠ¤æœåŠ¡
        
        Returns:
            bool: é‡å¯æ˜¯å¦æˆåŠŸ
        """
        print("ğŸ”„ é‡å¯å®ˆæŠ¤æœåŠ¡...")
        if self._is_running():
            if not self.stop_daemon():
                return False
            time.sleep(2)
        return self.start_daemon()
    
    def show_status(self) -> bool:
        """æ˜¾ç¤ºè¿è¡ŒçŠ¶æ€
        
        Returns:
            bool: æœåŠ¡æ˜¯å¦åœ¨è¿è¡Œ
        """
        if self._is_running():
            pid = self._get_running_pid()
            
            # è·å–è¿›ç¨‹å¯åŠ¨æ—¶é—´
            try:
                import psutil
                process = psutil.Process(pid)
                start_time = datetime.fromtimestamp(process.create_time())
                uptime = datetime.now() - start_time
                memory_mb = process.memory_info().rss / 1024 / 1024
                
                print("âœ… iSG App Guardian è¿è¡Œä¸­")
                print(f"   ğŸ†” è¿›ç¨‹PID: {pid}")
                print(f"   â±ï¸  å¯åŠ¨æ—¶é—´: {start_time.strftime('%Y-%m-%d %H:%M:%S')}")
                print(f"   â° è¿è¡Œæ—¶é•¿: {str(uptime).split('.')[0]}")
                print(f"   ğŸ’¾ å†…å­˜ä½¿ç”¨: {memory_mb:.1f} MB")
                print(f"   ğŸ“ å·¥ä½œç›®å½•: {self.work_dir}")
                print(f"   ğŸ“¡ ç›‘æ§ç›®æ ‡: {self.config['app']['package_name']}")
                
            except ImportError:
                print("âœ… iSG App Guardian è¿è¡Œä¸­")
                print(f"   ğŸ†” è¿›ç¨‹PID: {pid}")
                print(f"   ğŸ“ å·¥ä½œç›®å½•: {self.work_dir}")
                print("   ğŸ’¡ å®‰è£…psutilå¯æŸ¥çœ‹æ›´å¤šä¿¡æ¯: pip install psutil")
            except Exception as e:
                print("âœ… iSG App Guardian è¿è¡Œä¸­")
                print(f"   ğŸ†” è¿›ç¨‹PID: {pid}")
                print(f"   âš ï¸  è·å–è¯¦ç»†ä¿¡æ¯å¤±è´¥: {e}")
                
            # æ˜¾ç¤ºæœ€è¿‘çŠ¶æ€
            status_file = self.work_dir / 'data' / 'app_status.log'
            if status_file.exists():
                try:
                    with open(status_file, 'r') as f:
                        lines = f.readlines()
                        if lines:
                            print(f"   ğŸ“Š æœ€è¿‘çŠ¶æ€: {lines[-1].strip()}")
                except:
                    pass
        else:
            print("âŒ iSG App Guardian æœªè¿è¡Œ")
            
        return self._is_running()
    
    def show_logs(self):
        """æ˜¾ç¤ºå®æ—¶æ—¥å¿—"""
        if not self.log_file.exists():
            self._print_error("æ—¥å¿—æ–‡ä»¶ä¸å­˜åœ¨")
            return
            
        print(f"ğŸ“œ å®æ—¶æ—¥å¿— ({self.log_file}):")
        print("   æŒ‰ Ctrl+C é€€å‡º")
        print("-" * 50)
        
        try:
            # ç±»ä¼¼tail -fçš„åŠŸèƒ½
            with open(self.log_file, 'r') as f:
                # å…ˆæ˜¾ç¤ºæœ€å50è¡Œ
                lines = f.readlines()
                for line in lines[-50:]:
                    print(line.rstrip())
                
                # ç„¶åå®æ—¶è·Ÿè¸ªæ–°å†…å®¹
                while True:
                    line = f.readline()
                    if line:
                        print(line.rstrip())
                    else:
                        time.sleep(0.1)
                        
        except KeyboardInterrupt:
            print("\nğŸ“œ æ—¥å¿—æŸ¥çœ‹ç»“æŸ")
        except Exception as e:
            self._print_error(f"è¯»å–æ—¥å¿—å¤±è´¥: {e}")
    
    def _is_running(self) -> bool:
        """æ£€æŸ¥å®ˆæŠ¤æœåŠ¡æ˜¯å¦åœ¨è¿è¡Œ
        
        Returns:
            bool: æœåŠ¡æ˜¯å¦åœ¨è¿è¡Œ
        """
        if not self.pid_file.exists():
            return False
            
        try:
            with open(self.pid_file, 'r') as f:
                pid = int(f.read().strip())
            
            # æ£€æŸ¥è¿›ç¨‹æ˜¯å¦å­˜åœ¨
            os.kill(pid, 0)
            return True
            
        except (ValueError, ProcessLookupError, FileNotFoundError):
            # PIDæ–‡ä»¶æ— æ•ˆæˆ–è¿›ç¨‹ä¸å­˜åœ¨
            self._cleanup()
            return False
    
    def _get_running_pid(self) -> Optional[int]:
        """è·å–è¿è¡Œä¸­çš„è¿›ç¨‹PID
        
        Returns:
            int: PIDå·ï¼Œå¦‚æœä¸å­˜åœ¨è¿”å›None
        """
        try:
            with open(self.pid_file, 'r') as f:
                return int(f.read().strip())
        except:
            return None
    
    def _signal_handler(self, signum, frame):
        """ä¿¡å·å¤„ç†å™¨
        
        Args:
            signum: ä¿¡å·å·
            frame: å½“å‰æ ˆå¸§
        """
        print(f"ğŸ›‘ æ”¶åˆ°ä¿¡å· {signum}ï¼Œæ­£åœ¨åœæ­¢...")
        self.running = False
    
    def _cleanup(self):
        """æ¸…ç†èµ„æº"""
        if self.pid_file.exists():
            try:
                self.pid_file.unlink()
            except:
                pass
    
    def _print_error(self, message: str):
        """æ‰“å°é”™è¯¯ä¿¡æ¯
        
        Args:
            message: é”™è¯¯ä¿¡æ¯
        """
        print(f"âŒ é”™è¯¯: {message}", file=sys.stderr)


def main():
    """ä¸»å‡½æ•°"""
    parser = argparse.ArgumentParser(
        description="iSG App Guardian - è½»é‡çº§åº”ç”¨ç›‘æ§å®ˆæŠ¤æœåŠ¡",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
ä½¿ç”¨ç¤ºä¾‹:
  isg-guardian start      å¯åŠ¨å®ˆæŠ¤æœåŠ¡
  isg-guardian stop       åœæ­¢å®ˆæŠ¤æœåŠ¡
  isg-guardian restart    é‡å¯å®ˆæŠ¤æœåŠ¡
  isg-guardian status     æŸ¥çœ‹è¿è¡ŒçŠ¶æ€
  isg-guardian logs       æŸ¥çœ‹å®æ—¶æ—¥å¿—
  
ä¸“ä¸ºTermuxç¯å¢ƒè®¾è®¡ï¼Œç›‘æ§iSG Androidåº”ç”¨çš„è¿è¡ŒçŠ¶æ€
        """
    )
    
    parser.add_argument(
        'command',
        choices=['start', 'stop', 'restart', 'status', 'logs'],
        help='è¦æ‰§è¡Œçš„å‘½ä»¤'
    )
    
    parser.add_argument(
        '-v', '--version',
        action='version',
        version=f'iSG App Guardian {VERSION}'
    )
    
    # å¦‚æœæ²¡æœ‰å‚æ•°ï¼Œæ˜¾ç¤ºå¸®åŠ©
    if len(sys.argv) == 1:
        parser.print_help()
        sys.exit(1)
        
    args = parser.parse_args()
    
    # åˆ›å»ºå®ˆæŠ¤æœåŠ¡å®ä¾‹
    try:
        guardian = ISGGuardian()
    except Exception as e:
        print(f"âŒ åˆå§‹åŒ–å¤±è´¥: {e}")
        sys.exit(1)
    
    # æ‰§è¡Œå¯¹åº”å‘½ä»¤
    if args.command == 'start':
        success = guardian.start_daemon()
        sys.exit(0 if success else 1)
        
    elif args.command == 'stop':
        success = guardian.stop_daemon()
        sys.exit(0 if success else 1)
        
    elif args.command == 'restart':
        success = guardian.restart_daemon()
        sys.exit(0 if success else 1)
        
    elif args.command == 'status':
        is_running = guardian.show_status()
        sys.exit(0 if is_running else 1)
        
    elif args.command == 'logs':
        guardian.show_logs()
        sys.exit(0)


if __name__ == "__main__":
    main()